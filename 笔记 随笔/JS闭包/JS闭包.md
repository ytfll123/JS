#JS闭包#
<br>
##闭包的由来

我们已经清晰的知道，内部作用域可以引用外部作用域的标识符，但是外部作用域无法获取到内部作用域标识符，这很不方便，所以我们创造了一种方法来可以获取到任意作用域的标识符

##闭包的实质##

闭包的本质在于如果函数能够记住当前的词法作用域时，就产生了闭包，所以我们在写JS代码时，无时无刻都在使用闭包，但是我们有时却无法十分清晰的感知到闭包；

例如如下

	function foo(){
		var a = 2;
		function bar(){
			console.log（a);
		}
		bar();
	}
	foo()；

这个例子确实是一个闭包，但是却无法清晰的感受到闭包的思想，我们可能更愿意用词法作用域查询来表示这个例子，这样就无法感知到闭包的原理；

我们将以上代码更改一下，就可以清晰感知闭包的实现原理了：

	function foo(){
		var a = 2;
		function bar(){
			console.log（a);
		}
		return bar();
	}
	var a= foo()；

	a()；   //这就是闭包!!!

由于js引擎有垃圾回收机制，当foo执行完毕后，看上去foo（）已经并不会再引用，所以按道理说foo（）内部的作用域按理应当被销毁，而闭包可以有效的阻止这个行为，所以其实闭包的原理就是使得函数能够记住当前的作用域并避免被销毁而已；

##闭包的强大之处##

我们已经知道闭包的原理了，接下来就是考虑如何使用闭包，在闭包的使用场景中，没有比for循环更能说明一切的了

	for (var i=1; i<=5; i++) {
		setTimeout( function timer() {
			console.log( i );
		}, i*1000 );
	}

这是一个定时器，每1秒打印出一个i值，仔细看代码，理论上来说合乎逻辑，但是由于定时器的排队机制，使得每次打印的值均为5，为了解决类似的问题，我们可以在此使用闭包的方式；

代码修改如下

	for (var i=1; i<=5; i++) {
		(function(j) {
			setTimeout( function timer() {
				console.log( j );
			}, j*1000 );
		})( i );
	}


现在我们就知道了在哪些场景下应该使用闭包，以及如何使用闭包了，不过一般在循环和判断语句中，我们应当避免使用闭包，可以选择使用let语句来创建块级作用域；