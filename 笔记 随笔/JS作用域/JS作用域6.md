#JS作用域#
</b>
##3.3 函数作用域##

我们已经可以得知，在任意代码外部包裹一个函数可以使得内部代码隐藏，例如：

	function foo（）{
		var a = 3；
		console.log(a);
	)
	foo();

以上代码定义了一个名为foo的函数，并在外部对其进行了调用，这种方式隐藏内部代码是有问题的；首先我们必须先创建一个函数，并为这个函数命名，这样就会使得全局作用域中出现了一个名为foo的标识符；

其次，我们必须通过调用这个标识符才能使得代码执行，这为我们的代码正确执行带了一些麻烦；如果函数不需要函数名就可以直接执行，这样会更加的理想；

###匿名和具名###

对于函数表达式，其有匿名和具名两种，我们最熟悉的一种匿名函数表达式就是定时器函数

	setTimeout( function() {
		console.log("I waited 1 second!");
	}, 1000 );

由于函数本身没有标识符命名，这种函数被称为匿名函数，函数表达式是可以匿名的，但是函数声明是不可以匿名的，在JS中匿名的函数声明时违法的；

匿名函数在书写的时候非常简便，例如var x = function（）{}；但是这种写法也有几个缺点需要考虑；

1. 匿名函数在栈追踪（一种在内存中读取数据的机制，基于栈结构实现）时，因为没有具体的标识符会使调试变得有些困难；
2. 由于函数本身没有标识符，当在递归中调用自己的时候只能用过时的argument-callee指令，所以建议如果函数需要递归使用，最好给予标识符；
3. 匿名函数的可读性比较差，因为一个明确的标识符能有助于开发者明确了解函数的代码意义；

###立即执行函数表达式###

我们还可以使用（）来包裹匿名函数使得函数立即执行；当声明函数被小括号包裹时候就变为了函数表达式，并且这个函数表达式通过加上后边的一对小括号可以立即执行；例如

	（function (){var a = 2;console.log(a)}）();

这种模式有个术语，叫做IIFE，代表的是立即执行函数表达式（Immediately Involed Functiong Expression）；

IIFE的一种普遍的进阶的方式是把他们当作函数调用，别且传递参数进去
	var a = 2;
	(function IIFE( global ) {
	v	ar a = 3;
		console.log( a ); // 3
		console.log( global.a ); // 2
	})( window );
	console.log( a ); // 2

我们将window对象当作实参引入，但是给形参命名为window，这样使得全局变量的引用变得更加清晰；
这种方式并不局限于全局变量，实际上你可以将任何你想要传递东西从外部作用域传递进去，并将变量名命为你所熟悉的名字，这有助你改进你的代码风格；

这种方式可以用于判断undefined标识符有没有定义其他的值，虽然这种并不常见；

	(function IIFE( undefined ) {
		var a;
		if (a === undefined) {
		console.log( "Undefined is safe here!" );
		}
	})();
这是在函数表达式内部定义了一个变量a，但是并不赋值，确保a的值任何情况下都为undefined；然后通过传参对undefined值做比较；