#JS作用域#
</b>
##2 词法作用域##

词法作用域一共有两种模式，一种是普遍的，被大多数编程语言所采用的，叫做词法作用域；另一种是动态作用域，JS中并不采用，暂时不做了解；

###2.1 词法阶段###

一般我们编译器编译代码时的第一个工作叫做词法化（单词化）；词法化会对代码逐一进行检查。

换句话来说，词法作用域就是在你写代码时规定的块以及变量的作用域，因此当词法分析器处理会保持作用域不变（JS中有欺骗词法作用域的写法，下边单独讨论）；

	function foo(a) {
		var b = a * 2;`
		function bar(c) {
		console.log( a, b, c );
		} 
		bar( b * 3 );
	} 

	foo( 2 ); // 2, 4, 12

这个例子中有三个嵌套的作用域

1. 首先是全局作用域里边有一个foo标识符；
2. 然后是foo作用域，里边包含着a,b,bar三个标识符；
3. 最后是标识符bar所创建的作用域；

**查找**、

作用域的结构和相对的位置给引擎提供了位置信息，引擎利用这些位置找到相对的标识符，进而找到对应的作用域；

全局变量会自动生成为全局对象（比如window）的属性，因此可以利用window.a来直接调用；

##2.2 eval()##

JS中给我们提供了一个函数叫做eval()，这是一种欺骗作用域的写法，eval()函数中可以跟字符串作为参数，并且将其中内容视为一开始书写时就在的位置，也就是一种动态插入代码的方式  比如以下代码

	function foo(str, a) {
		eval( str ); // 欺骗！
		console.log( a, b );
	}
	var b = 2;
	foo( "var b = 3;", 1 ); // 1, 3

eval()中调用的var b = 3会被当作本来就出现在那里的写法；所以会在函数内部创造一个标识符为b的作用域，并且屏蔽掉外部的标识符b；

##2.3 with语句##

JS中还有一个比较难于理解的语句叫做with()，某种意义上，with语句也会造成欺骗词法作用域的效果；

我们使用with是为了避免重复书写相同的东西，但是with有这不可忽视的副作用，例如

	function foo(obj) {
		with (obj) {
			a = 2;
		}
	}
	var o2 = {
		b: 3
	};
	
	foo( o2 );
	console.log( o2.a ); // undefined
	console.log( a ); // 2

这里有个特殊的效果就是，a被定义成为了全局变量，这是因为with机制会将当前的对象放入一个with语句所创建的一个新的作用域，并且分配一个新的标识符，这种机制很难理解，但是就是这么操作的，这意味着原先我们定义时所分配的作用域被完全抛弃了，所以with语句会大大增加代码的运行时间，如果你在你的代码中使用了过多的with，这会将使你的代码加载速度变得非常慢；

继续看我们的代码  当调用foo并传参o2时  因为在当前的o2的作用域内找不到a标识符，这时候执行a=2就会在全局中创建一个a变量，并赋值为2；

某种意义上说，with会脱离我们的正常作用域，所以尽量在代码中不要使用with；


##性能##

with和eval()理论上可以为我们增加了更多的代码的可扩展性，但是在引擎看来这是并不可取的方法，因为我们的引擎会在编译时对代码进行多种优化，而使用eval()和with则让这个优化变得十分困难，因为引擎也不确定eval()内会接受到什么样的字符串，也无法确定with的对象，所以引擎会对这两部分采取不优化的方案，这使得你的代码执行时间将会大大加长，所以尽量避免在书写代码时使用欺骗作用域的做法；