#JS作用域#
</b>
##3 函数作用域和块作用域##

我们已经知道作用域是一系列的容器，内部包含有标识符和变量等一系列东西，这些容器相互嵌套并成树状结构分布，那么到底是什么创建这些容器，除去函数，其他的结构能否生成作用域吗？

##3.1 函数中的作用域##

函数会创建一个自己的作用域，这个作用域的位置是属于函数本身，外部无法从函数内部的作用域中调取变量和参数等。相反，函数内部可以调用外部的作用域，并且寻找到外部作用域内定义的标识符；

##3.2 代码的隐藏##

我们传统的对于函数的认知是，首先我们要先声明一个函数，然后在其函数内部再书写代码，在作用域范畴，我们认知是声明了一个作用域，并在这个作用域内添加代码，反过来看，我们也是相当于在代码外部包裹了一层气泡（也就是作用域），使得外部不能访问到内部的代码，这种方式叫做代码的隐藏；

这个隐藏方式是基于最小特权原则来实现，最小特权原则就是在软件设计过程中应该最小程度暴露必要的内容，而将其他都隐藏起来，比如模块以及API设计;

###规避冲突###

隐藏的另一个好处就是可以避免同名标识符之间的冲突，若在都在同一作用域下写代码，则有可能会有相同命名但有不同的作用的标识符，后边会覆盖掉前边的标识符，使用代码隐藏则会使得作用域内部和外部分隔开，可以有效避免标识符重名的情况

###全局作用域冲突###

标识符冲突的另一个方面就是当你的代码使用多个第三方库的时候，这些库如果没有合理的将内部的代码隐藏起来，而是暴露在了全局作用域中，这时候就很可能引发冲突（除非你熟知这些库的各种标识符，但这样可以规避一些冲突，但是最佳的解决办法还是将内部的代码隐藏起来，只暴露必要的函数名标识符就好）；

**合理的库规则**

我们写第三方插件或者库的时候也应当遵循最小特权原则，即尽量只在全局作用域中声明一个足够特别的标识符，用来标识我们写的对象，而将大部分代码通过函数作用隐藏起来,例如：

	var MyReallyCoolLibrary = {
		awesome: "stuff",
		doSomething: function() {
		// ...
		},
		doAnotherThing: function() {
		// ...
		}
	};

