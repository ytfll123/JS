#JS作用域#
</b>
##3.4 块作用域##

尽管函数作用域是最常见的作用域单元，但是其他类型的作用域也是存在的，熟练使用这些作用域将会使得你的代码更加的简介，优秀以及便于维护；

	for（var i=0;i<10;i++）{
		console.log(i);
	}

通常我们在for循环头部定义了变量i，是想要只在for循环内部使用i，而忽略i会被绑定在外部作用域的本质；

	var foo = true;
	if (foo) {
	var bar = foo * 2;
	bar = something( bar );
	console.log( bar );
	}

虽然bar变量在if判断语句内部定义，但是使用var定义的标识符，不管写在哪里都是一样的，因为他们最终都会绑定在外部作用域；

现在看来，JS并没有块作用域的机制，除非你深入研究JS的作用域机制；

###with###

利用with关键字所创建的作用域只在with所在的作用域生效而非外部的作用域；

###try/catch###

ES3中规定try/catch中的catch分句也会创建一个块作用域，catch中声明的变量只能用于catch内部，在外部调用则会报错；

###let###

可能到此为止，JS的块级作用域总会掺杂着一些奇怪的功能，但是如果仅仅是这样，那么块级作用域也不会成为我们的一个非常有用的机制了；

ES6中引入了一个新的关键字叫做let，let给我们提供了除了var以外的另一种声明变量的方式；

使用let声明的变量将会绑定到块级作用域当中**这和var不同，用var声明的变量只能绑定到全局和函数作用域之内；**，

例如：

	for（let i = 0；i < 10; i++）{
		console.log(i);
	}

	console.log(i) //error；

let还有一个非常不错的机制就是在于for循环是，每个单次循环内绑定的i都是一个新的变量，这点非常有用。留待闭包之后说明；

当然，这也牵扯到了一个问题，若每次循环时都绑定了一个新的i，那么为什么会输出的是0,1,2,3,4,5。。。而不是全是0呢；

这是因为JS引擎会记住本次循环后的值，当下次循环初始化变量i的时候，是在上一轮值得基础上计算的；

**另外，针对于块级作用域中得for作用域有个特别之处在于，设置循环变量的那部分是一个父级作用域，而循环体内部是一个单独的子作用域；**

###const###

ES6中还为我们规定了另一个创建块级作用域变量的声明方式叫做const；

	for（let i = 0；i < 10; i++）{
		const b = 1;
		console.log(i);
	}

	console.log(b) //error；

但是要注意一点const创建的块级作用域标识符是唯一的（类似ID），并且是属于常量，任何更改都会报错

	const b = 1；
	b = 4 //error；


##3.5 提升##

JS的编译器在读取代码时，会有一个预编译的过程；例如

	console.log(x);
	var x = 2;

此处代码会输出undefined，这就是因为编译器会预先将变量和函数的声明在运行前提前处理；

**注意一个细节，函数的声明要比变量的声明还要提前**

**另外，使用let声明的变量并不会被提升，这点要切记**